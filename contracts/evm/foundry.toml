[profile.default]
src = "src"
out = "out"
libs = ["lib"]
ignored_error_codes = [
  2394,
  5574,
  3860,
] # Silence transient storage composability warning and test code warnings

# See more config options https://github.com/foundry-rs/foundry/blob/master/crates/config/README.md#all-options
solc_version = '0.8.26'
evm_version = "cancun"   # hard fork that enabled EIP-1153
gas_limit = "3000000000"
# fuzz_runs = 10_000
optimizer_runs = 20000
# optimizer_runs = 44444444
optimizer = true
via_ir = true
ffi = true

bytecode_hash = "none"

fs_permissions = [
  { access = "read-write", path = "./deployments" },
  { access = "read-write", path = ".forge-snapshots/" },
  { access = "read", path = "out/" },
  # Allow debug-mode NDJSON logging from tests via `vm.writeLine`.
  { access = "read-write", path = "../../.cursor/" },
]

remappings = [
  "@openzeppelin/=lib/openzeppelin-contracts/",
  "reactive/=../reactive/src/",
]

allow_paths = ["../reactive/src"]

# Foundry automatically instruments linked-libraries if library public/external functions are called.
# Defaulting to predicted addresses via CREATE3Factory.
# TODO: Hard-linked libraries are causing tests to fail.
# libraries = [
#   "src/libraries/VTSPositionLib.sol:VTSPositionLib:0x2C95130C4DE0504c82f4688C657c9A4CC01761EF",
#   "src/libraries/VTSSwapLib.sol:VTSSwapLib:0x8AF1433f3d2b0547A63f7004B9dA9C5953fD522D",
#   "src/libraries/VTSCommitLib.sol:VTSCommitLib:0x6EBB20A904a9CA505e7d4A253c7FbF72DF5a777b",
#   "src/libraries/LCCFactoryLib.sol:LCCFactoryLinkedLib:0x3209860215dB283218CBc8f0D5acf57Ae8874C85",
#   "src/libraries/VTSFeeLib.sol:VTSFeeLinkedLib:0x0000000000000000000000000000000000000000",
# ]


# additional_compiler_profiles = [
#   { name = "market", via_ir = true, optimizer_runs = 30000 },
#   { name = "descriptor", via_ir = true, optimizer_runs = 1 },
#   { name = "test", via_ir = false },
# ]

# compilation_restrictions = [
#   { paths = "src/MMPositionManager.sol", optimizer_runs = 30000 },
#   { paths = "src/MMPositionActionsImpl.sol", optimizer_runs = 30000 },
#   { paths = "src/MarketVaultDeployer.sol", optimizer_runs = 30000 },
#   { paths = "src/MMPCommitmentDescriptor.sol", optimizer_runs = 1 },
#   { paths = "test/**", via_ir = false },
# ]

# The above compilation_restrictions and additional_compiler_profiles are not working as expected.
# The real conflict is your Foundry “compilation restrictions” forcing different optimizer_runs for different source files that end up in the same compilation unit (your test imports them together).
# TODO: MarketTestBase.sol import list includes both src/MMPositionManager.sol (30000 runs) and src/MMPCommitmentDescriptor.sol (1 run) (and MMPositionActionsImpl.sol at 30000), so Forge can’t compile that test in a single job
# We must split this up. MarketFactory overhaul should resolve this.

# [lint]
# exclude_lints = [
#   "screaming-snake-case-immutable",
#   "mixed-case-variable",
#   "mixed-case-function",
# ]

[profile.debug]
via_ir = false
optimizer_runs = 200
fuzz.runs = 100

[profile.solx]
solc_version = '../../.solx/solx'
auto_detect_solc = false
via_ir = false

[profile.ci]
# Disable via_ir to reduce memory usage in CI environments
# This is sufficient for testing - production builds should use default profile
via_ir = false
optimizer_runs = 200
fuzz.runs = 1000

[profile.echidna]
# Dedicated profile for Echidna's Foundry backend:
# - compile only the echidna harnesses under `test/fuzz` (avoids OOM / exit-137)
# - output to a separate directory so crytic-compile can consume it deterministically
# - hard-link `LCCFactoryLinkedLib` so HEVM doesn't reject unlinked placeholders
via_ir = false
optimizer = true
optimizer_runs = 200
test = "test/fuzz"
out = "out-echidna"
libraries = [
  "src/libraries/LCCFactoryLib.sol:LCCFactoryLinkedLib:0xE2B5401952dC4c9059b7eDE3a1742bF2BC17EBAd",
  # Prevent HEVM crashes by eliminating unlinked placeholders in unrelated contracts (e.g. VTSOrchestrator).
  # Deterministic CREATE2 address deployed by the SIG-BACKING harness (avoids any RPC fetch attempts).
  "src/libraries/VTSCommitLib.sol:VTSCommitLib:0x08f6e330612797F445209Bfee166c949cfd0BF4F",
  # Deterministic CREATE2 address deployed by `VTSPositionLibEchidnaHarness` (avoids Echidna RPC fetch attempts).
  "src/libraries/VTSPositionLib.sol:VTSPositionLib:0xa05ceC1A8F8639C0432Fa44FDd62d77bBcA4d211",
  "src/libraries/VTSSwapLib.sol:VTSSwapLib:0x8AF1433f3d2b0547A63f7004B9dA9C5953fD522D",
  "src/libraries/VTSFeeLib.sol:VTSFeeLinkedLib:0x1111111111111111111111111111111111111111",
]

[profile.mutation]
via_ir = false
optimizer = false
optimizer_runs = 0
# Mutation builds often change inlining behaviour; if we keep hard-linked library addresses here,
# calls can surface to addresses that have no code in the test VM (e.g. "delegatecall to non-contract").
# For mutation runs, prefer Foundry's auto-deploy/auto-link behaviour.
libraries = []

[rpc_endpoints]
local = "${ANVIL_FORK_URL}"
sepolia = "${ARB_SEPOLIA_RPC_URL}"
arbitrum = "${ARB_MAINNET_RPC_URL}"
ethsepolia = "${ETH_SEPOLIA_RPC_URL}"

# For some reason etherscan api is required for local anvil fork.
[etherscan]
sepolia = { key = "${ETHERSCAN_API_KEY}" }
arbitrum = { key = "${ETHERSCAN_API_KEY}" }
