# WIP: Fiet Maker Kernel Intent Validator (Stylus)

![Image](./header.png)

Arbitrum Stylus program written in Rust using the [stylus-sdk](https://github.com/OffchainLabs/stylus-sdk-rs).

This crate hosts the on-chain **“Atomic Revalidation” intent validator** described in `PROPOSAL.md`, exposed as a **Kernel-compatible** `IValidator` (and optional `IHook`) module.

The current implementation is a scaffold (fails closed) — see `fiet-maker-intent-validator/src/intent_validator.rs` for the intended storage layout and module hooks.

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

// ABI is generated from Rust (see: `cargo stylus export-abi`).
// Function names/types below are illustrative only.
interface IIntentValidator {
    // ERC-7579 / Kernel module lifecycle
    function onInstall(bytes calldata data) external payable;
    function onUninstall(bytes calldata data) external payable;
    function isModuleType(uint256 moduleTypeId) external view returns (bool);
    function isInitialized(address smartAccount) external view returns (bool);

    // Kernel validator surface
    function validateUserOp(bytes calldata packedUserOp, bytes32 userOpHash) external payable returns (uint256);
    function isValidSignatureWithSender(address sender, bytes32 hash, bytes calldata data) external view returns (bytes4);
}
```

If you want a more minimal Stylus example (not a Kernel validator), use `cargo stylus new --minimal <YOUR_PROJECT_NAME>` under [OffchainLabs/cargo-stylus](https://github.com/OffchainLabs/cargo-stylus).

## Quick Start 

Install [Rust](https://www.rust-lang.org/tools/install), and then install the Stylus CLI tool with Cargo

```bash
cargo install --force cargo-stylus cargo-stylus-check
```

Add the `wasm32-unknown-unknown` build target to your Rust compiler:

```bash
rustup target add wasm32-unknown-unknown
```

You should now have it available as a Cargo subcommand:

```bash
cargo stylus --help
```

From the repo root, you’ll typically work in:

```bash
cd protocol/contracts/stylus
```

The actual Stylus contract crate lives in:

```bash
cd fiet-maker-intent-validator
```

### Testnet Information

All testnet information, including faucets and RPC endpoints can be found in [Stylus testnet information](https://docs.arbitrum.io/stylus/reference/testnet-information).

### ABI Export

You can export the Solidity ABI for your program by using the `cargo stylus` tool as follows:

```bash
cd fiet-maker-intent-validator
cargo stylus export-abi
```

which outputs a Solidity interface for this program (names/types depend on the current Rust implementation), for example:

```js
/**
 * This file was automatically generated by Stylus and represents a Rust program.
 * For more information, please see [The Stylus SDK](https://github.com/OffchainLabs/stylus-sdk-rs).
 */

// SPDX-License-Identifier: MIT-OR-APACHE-2.0
pragma solidity ^0.8.23;

interface IIntentValidator {
    function onInstall(bytes calldata data) external payable;
    function onUninstall(bytes calldata data) external payable;
    function isModuleType(uint256 moduleTypeId) external view returns (bool);
    function isInitialized(address smartAccount) external view returns (bool);
}
```

Exporting ABIs uses a feature that is enabled by default in your Cargo.toml:

```toml
[features]
export-abi = ["stylus-sdk/export-abi"]
```

## Deploying

You can use the `cargo stylus` command to also deploy your program to the Stylus testnet. We can use the tool to first check
our program compiles to valid WASM for Stylus and will succeed a deployment onchain without transacting. By default, this will use the Stylus testnet public RPC endpoint. See here for [Stylus testnet information](https://docs.arbitrum.io/stylus/reference/testnet-information)

```bash
cd fiet-maker-intent-validator
cargo stylus check
```

If successful, you should see:

```bash
Finished release [optimized] target(s) in 1.88s
Reading WASM file at target/wasm32-unknown-unknown/release/<crate_name>.wasm
Compressed WASM size: 8.9 KB
Program succeeded Stylus onchain activation checks with Stylus version: 1
```

Next, we can estimate the gas costs to deploy and activate our program before we send our transaction. Check out the [cargo-stylus](https://github.com/OffchainLabs/cargo-stylus) README to see the different wallet options for this step:

```bash
cd fiet-maker-intent-validator
cargo stylus deploy \
  --private-key-path=<PRIVKEY_FILE_PATH> \
  --estimate-gas
```

You will then see the estimated gas cost for deploying before transacting:

```bash
Deploying program to address e43a32b54e48c7ec0d3d9ed2d628783c23d65020
Estimated gas for deployment: 1874876
```

The above only estimates gas for the deployment tx by default. To estimate gas for activation, first deploy your program using `--mode=deploy-only`, and then run `cargo stylus deploy` with the `--estimate-gas` flag, `--mode=activate-only`, and specify `--activate-program-address`.

Here's how to deploy:

```bash
cd fiet-maker-intent-validator
cargo stylus deploy \
  --private-key-path=<PRIVKEY_FILE_PATH>
```

The CLI will send 2 transactions to deploy and activate your program onchain.

```bash
Compressed WASM size: 8.9 KB
Deploying program to address 0x457b1ba688e9854bdbed2f473f7510c476a3da09
Estimated gas: 1973450
Submitting tx...
Confirmed tx 0x42db…7311, gas used 1973450
Activating program at address 0x457b1ba688e9854bdbed2f473f7510c476a3da09
Estimated gas: 14044638
Submitting tx...
Confirmed tx 0x0bdb…3307, gas used 14044638
```

Once both steps are successful, you can interact with your program as you would with any Ethereum smart contract.

## Deploying (and writing `deployments.json`)

If you want to keep the standard `cargo stylus deploy` flow **but** also record the deployed address for tooling and integration tests, use the thin wrapper in `tools/deployer`.

It runs `cargo stylus deploy` under the hood, parses the deployed address / tx hashes from its output, then writes/updates a `deployments.<env>.json` file.

```bash
cd protocol/contracts/stylus

# Example: devnet or testnet
cargo run --manifest-path tools/deployer/Cargo.toml -- \
  --rpc-url "$RPC_URL" \
  --private-key-path "$PRIV_KEY_PATH" \
  --deployments-path deployments.devnet.json \
  --contract-key intent-validator \
  --network devnet
```

## Install on a Kernel smart wallet (as a validator module)

This section describes how to:

- deploy the Stylus validator (this crate), then
- install it on an existing **Kernel v3** smart wallet as an **ERC-7579 validator module**.

### 1) Deploy the validator contract

Deploy and activate as above:

```bash
cargo stylus check
cargo stylus deploy --private-key-path <PRIVKEY_FILE_PATH>
```

Record the deployed program address (this is the validator module address you’ll install on the Kernel account).

### 2) Export the ABI (recommended)

Export a Solidity ABI for the deployed module (useful for tooling, encoding calldata, and local testing):

```bash
cargo stylus export-abi
```

### 3) Decide what `validatorData` is for `onInstall`

`IntentValidator.on_install` currently expects a very small init payload:

- first 20 bytes: the **authorised signer** address for the Kernel smart account being configured.

So your `validatorData` will typically be:

```text
validatorData = abi.encodePacked(authorisedSignerAddress)
```

Notes:

- `msg.sender` during `onInstall` is the **Kernel account** (Kernel calls the module during installation), so the module stores configuration *per smart account*.
- `onUninstall` clears the stored signer and nonce for that Kernel account, so reinstalling is supported.

### 4) Call `Kernel.installModule(MODULE_TYPE_VALIDATOR, module, initData)` via a UserOperation

Kernel’s `installModule(...)` is restricted (it’s not a plain EOA call). In practice you install modules by submitting an **ERC-4337 UserOperation** that calls `installModule` on the account.

For validator install, Kernel expects:

- `moduleTypeId = 1` (validator)
- `module = <deployed validator address>`
- `initData = abi.encodePacked(hook, abi.encode(validatorData, hookData, selectorData))`

Where:

- `hook`: 20 bytes. Use `address(0)` if you do not want a hook (Kernel treats this as “no hook required”).
- `validatorData`: bytes passed to `onInstall` (see above).
- `hookData`: bytes passed to the hook’s `onInstall` (empty if no hook).
- `selectorData`: optional. If you pass exactly 4 bytes, Kernel may grant access for that selector to the newly installed validator.

Here’s a minimal encoding example (TypeScript + ethers) for the `installModule` call data:

```ts
import { ethers } from "ethers";

const KERNEL_ABI = [
  "function installModule(uint256 moduleType, address module, bytes initData) external payable",
];

const MODULE_TYPE_VALIDATOR = 1;

const kernelAccount = "0x...";       // existing Kernel smart wallet address
const validatorModule = "0x...";     // address output by `cargo stylus deploy`
const authorisedSigner = "0x...";    // signer you want the validator to accept for this Kernel account

const hook = ethers.ZeroAddress;     // no hook
const validatorData = ethers.solidityPacked(["address"], [authorisedSigner]);
const hookData = "0x";
const selectorData = "0x";           // optional: 4-byte selector to grant

const initData = ethers.concat([
  ethers.zeroPadValue(hook, 20),
  ethers.AbiCoder.defaultAbiCoder().encode(
    ["bytes", "bytes", "bytes"],
    [validatorData, hookData, selectorData]
  ),
]);

const kernel = new ethers.Interface(KERNEL_ABI);
const callData = kernel.encodeFunctionData("installModule", [
  MODULE_TYPE_VALIDATOR,
  validatorModule,
  initData,
]);

console.log({ callData });
```

You then submit a UserOperation with `callData` set to that encoded `installModule(...)` call, signed by whatever **root authorisation** your Kernel account uses (eg, EIP-7702 delegation key for 7702 wallets, or the configured root validator for non-7702 Kernel accounts).

### 4b) ZeroDev SDK shortcuts (TypeScript)

If you’re already using the ZeroDev SDK, there are higher-level TypeScript methods that can make validator installation/uninstallation faster than manually encoding `Kernel.installModule(...)`.

#### Install a custom validator during account creation (`pluginMigrations`)

If you can install the validator **at account creation time**, you can provide the deployed validator address and `onInstall` data via `pluginMigrations`:

```ts
import { createKernelAccount } from "@zerodev/sdk";
import { PLUGIN_TYPE } from "@zerodev/sdk/constants";

const validatorModuleAddress = "0x..."; // deployed Stylus program address
const authorisedSigner = "0x..."; // signer your validator should accept for this Kernel account

// Our Stylus validator expects `onInstall(data)` where `data = abi.encodePacked(authorisedSigner)`
const onInstallData = authorisedSigner as `0x${string}`; // 20-byte packed address

const account = await createKernelAccount(publicClient, {
  entryPoint,
  kernelVersion,
  plugins: {
    sudo: ecdsaValidator,
  },
  pluginMigrations: [
    {
      address: validatorModuleAddress,
      type: PLUGIN_TYPE.VALIDATOR,
      data: onInstallData,
    },
  ],
});
```

This causes the validator’s `onInstall` to run as part of the account’s setup (so the validator is ready immediately).

#### Enable a regular validator “lazily” (`plugins.regular`)

Kernel/ZeroDev commonly enable non-sudo validators “lazily”: when you send the **first UserOp** with an `account` configured with a `regular` plugin, that UserOp also enables the plugin.

This is the smoothest UX when:

- you already have a sudo validator (or a 7702 account acting as root authorisation), and
- you can represent your validator as a ZeroDev “plugin” object.

If you can’t (yet) represent the validator as a plugin object, use the raw `installModule` calldata approach in the previous section.

#### Uninstall (revoke) a plugin via `kernelClient.uninstallPlugin`

For removal/revocation, ZeroDev exposes an `uninstallPlugin` helper on the Kernel client (typically done from a “sudo” account/client that has privileges):

```ts
const txHash = await sudoKernelClient.uninstallPlugin({
  plugin: permissionPlugin, // or your custom plugin object, if wrapped
});
```

Notes:

- `uninstallPlugin` operates on a **plugin object** (not just a raw address). For custom modules, you’ll generally want a small wrapper that describes how to uninstall it (module address, type, and uninstall data).
- Our validator’s `onUninstall` currently clears its stored signer/nonce for the Kernel account, so uninstalling is safe and reinstalling is supported.

### 5) (Optional) Uninstall later

You can uninstall the module using either:

- `Kernel.uninstallValidation(vId, deinitData, hookDeinitData)` (Kernel’s validation-aware uninstall), or
- `Kernel.uninstallModule(MODULE_TYPE_VALIDATOR, module, deInitData)` (generic ERC-7579 uninstall).

For this module, `deInitData` can be empty (`0x`) unless you add additional uninstall-time checks/data later.

## Calling Your Program

Stylus programs are Ethereum ABI equivalent. You can call this validator module with standard EVM tooling, but most of the time it’s invoked *by Kernel* (eg, `validateUserOp` during ERC-4337 validation) rather than by end-users directly.

For basic sanity checks, you can call view methods like `isModuleType` and `isInitialized`:

```rs
abigen!(
    IntentValidator,
    r#"[
        function isModuleType(uint256 moduleTypeId) external view returns (bool)
        function isInitialized(address smartAccount) external view returns (bool)
    ]"#
);
let validator = IntentValidator::new(address, client);
let is_validator = validator.is_module_type(1u64.into()).call().await?;
println!("is validator module type? {:?}", is_validator);

let kernel_account: ethers::types::Address = "0x0000000000000000000000000000000000000000".parse()?;
let initialised = validator.is_initialized(kernel_account).call().await?;
println!("is initialised for Kernel account? {:?}", initialised);
```

Before running, set the following env vars or place them in a `.env` file (see: [.env.example](./.env.example)) in this project:

```dotenv
RPC_URL=https://sepolia-rollup.arbitrum.io/rpc
STYLUS_CONTRACT_ADDRESS=<the onchain address of your deployed program>
PRIV_KEY_PATH=<the file path for your priv key to transact with>
```

Next, run:

```bash
cargo run --target=<YOUR_ARCHITECTURE>
```

Where you can find `YOUR_ARCHITECTURE` by running `rustc -vV | grep host`. For M1 Apple computers, for example, this is `aarch64-apple-darwin` and for most Linux x86 it is `x86_64-unknown-linux-gnu`

## Build Options

By default, the cargo stylus tool will build your project for WASM using sensible optimisations, but you can control how this gets compiled by seeing the full README for [cargo stylus](https://github.com/OffchainLabs/cargo-stylus). If you wish to optimise the size of your compiled WASM, see the [optimising binaries guide](https://github.com/OffchainLabs/cargo-stylus/blob/main/OPTIMIZING_BINARIES.md).

## Peeking Under the Hood

The [stylus-sdk](https://github.com/OffchainLabs/stylus-sdk-rs) contains many features for writing Stylus programs in Rust. It also provides helpful macros to make the experience for Solidity developers easier. These macros expand your code into pure Rust code that can then be compiled to WASM. If you want to see what this crate expands into, you can use `cargo expand` to inspect the Rust that will be deployed onchain.

First, run `cargo install cargo-expand` if you don't have the subcommand already, then:

```bash
cargo expand --all-features --release --target=<YOUR_ARCHITECTURE>
```

Where you can find `YOUR_ARCHITECTURE` by running `rustc -vV | grep host`. For M1 Apple computers, for example, this is `aarch64-apple-darwin`.

## Integration runner (devnet / testnet)

There’s a minimal integration harness in `integration/` that reads the deployed address from `deployments.<env>.json` and runs a few on-chain sanity checks (module type detection + install/uninstall state transitions).

```bash
cd protocol/contracts/stylus

cargo run --manifest-path integration/Cargo.toml -- \
  --rpc-url "$RPC_URL" \
  --private-key-path "$PRIV_KEY_PATH" \
  --deployments-path deployments.devnet.json \
  --contract-key intent-validator
```
